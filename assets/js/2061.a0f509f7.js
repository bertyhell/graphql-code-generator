"use strict";(self.webpackChunk_graphql_codegen_website=self.webpackChunk_graphql_codegen_website||[]).push([[2061],{2061:function(e,n,o){o.d(n,{jf:function(){return ee}});var i,t=o(84553),s=o(12640),r=o(18666),l=o(43903),c=o(37358),a=o(33277),u=o(57554),d=o(23476),f=o(65449),v=o(14734),p=o(82299);function E(e,n){if(!e||Array.isArray(e)&&0===e.length)return{};if(!Array.isArray(e))return e;if(1===e.length)return e[0]||{};const o=new Array;for(let t of e)Array.isArray(t)&&(t=E(t)),"object"==typeof t&&t&&o.push(t);const i=(0,c.Ee)(o,!0);if(null==n?void 0:n.exclusions)for(const t of n.exclusions){const[e,n]=t.split(".");n&&"*"!==n?i[e]&&delete i[e][n]:delete i[e]}return i}function T(e,n,o){const i=[...n,...e].filter(c.pC).reduce(((e,n)=>e.find((e=>e.name.value===n.name.value))?e:e.concat([n])),[]);return o&&o.sort&&i.sort(c.YU),i}function m(e,n){return!!e.find((e=>e.name.value===n.name.value))}function N(e,n){const o=[...n];for(const i of e){const e=o.findIndex((e=>e.name.value===i.name.value));if(e>-1){const n=o[e];if("ListValue"===n.value.kind){const e=n.value.values,o=i.value.values;n.value.values=y(e,o,((e,n)=>{const o=e.value;return!o||!n.some((e=>e.value===o))}))}else n.value=i.value}else o.push(i)}return o}function _(e=[],n=[],o){const i=o&&o.reverseDirectives,t=i?n:e,s=[...i?e:n].map(((e,n,o)=>{const i=o.findIndex((n=>n.name.value===e.name.value));if(i!==n){const n=o[i];return e.arguments=N(e.arguments,n.arguments),null}return e})).filter(c.pC);for(const r of t)if(m(s,r)){const e=s.findIndex((e=>e.name.value===r.name.value)),n=s[e];s[e].arguments=N(r.arguments||[],n.arguments||[])}else s.push(r);return s}function h(e,n){return n?(function(e,n){const o=(0,a.S)({...e,description:void 0}),i=(0,a.S)({...n,description:void 0}),t=new RegExp("(directive @w*d*)|( on .*$)","g");if(o.replace(t,"")!==i.replace(t,""))throw new Error(`Unable to merge GraphQL directive "${e.name.value}". \nExisting directive:  \n\t${i} \nReceived directive: \n\t${o}`)}(e,n),{...e,locations:[...n.locations,...e.locations.filter((e=>!function(e,n){return n.some((({value:n})=>n===e.value))}(e,n.locations)))]}):e}function y(e,n,o){return e.concat(n.filter((n=>o(n,e))))}function I(e,n,o){if(null==o?void 0:o.consistentEnumMerge){const o=[];e&&o.push(...e),e=n,n=o}const i=new Map;if(e)for(const s of e)i.set(s.name.value,s);if(n)for(const s of n){const e=s.name.value;if(i.has(e)){const n=i.get(e);n.description=s.description||n.description,n.directives=_(s.directives,n.directives)}else i.set(e,s)}const t=[...i.values()];return o&&o.sort&&t.sort(c.YU),t}function x(e,n,o){return n?{name:e.name,description:e.description||n.description,kind:(null==o?void 0:o.convertExtensions)||"EnumTypeDefinition"===e.kind||"EnumTypeDefinition"===n.kind?"EnumTypeDefinition":"EnumTypeExtension",loc:e.loc,directives:_(e.directives,n.directives,o),values:I(e.values,n.values,o)}:(null==o?void 0:o.convertExtensions)?{...e,kind:u.h.ENUM_TYPE_DEFINITION}:e}function A(e){let n=e;for(;n.kind===u.h.LIST_TYPE||"NonNullType"===n.kind;)n=n.type;return n}function g(e){return e.kind!==u.h.NAMED_TYPE}function O(e){return e.kind===u.h.LIST_TYPE}function b(e){return e.kind===u.h.NON_NULL_TYPE}function S(e){return O(e)?`[${S(e.type)}]`:b(e)?`${S(e.type)}!`:e.name.value}function F(e,n){return null==e&&null==n?i.A_EQUALS_B:null==e?i.A_SMALLER_THAN_B:null==n?i.A_GREATER_THAN_B:e<n?i.A_SMALLER_THAN_B:e>n?i.A_GREATER_THAN_B:i.A_EQUALS_B}function w(e,n,o){const i=e.find((e=>e.name.value===n.name.value));if(i&&!(null==o?void 0:o.ignoreFieldConflicts)){const e=A(i.type),o=A(n.type);if(e.name.value!==o.name.value)throw new Error(`Field "${n.name.value}" already defined with a different type. Declared as "${e.name.value}", but you tried to override with "${o.name.value}"`)}return!!i}function D(e,n,o,i){const t=[];if(null!=o&&t.push(...o),null!=n)for(const s of n)if(w(t,s,i)){const n=t.find((e=>e.name.value===s.name.value));(null==i?void 0:i.ignoreFieldConflicts)||((null==i?void 0:i.throwOnConflict)?k(e,n,s,!1):k(e,n,s,!0),b(s.type)&&!b(n.type)&&(n.type=s.type)),n.arguments=T(s.arguments||[],n.arguments||[],i),n.directives=_(s.directives,n.directives,i),n.description=s.description||n.description}else t.push(s);if(i&&i.sort&&t.sort(c.YU),i&&i.exclusions){const n=i.exclusions;return t.filter((o=>!n.includes(`${e.name.value}.${o.name.value}`)))}return t}function k(e,n,o,i=!1){const t=S(n.type),s=S(o.type);if(t!==s&&!R(n.type,o.type,i))throw new Error(`Field '${e.name.value}.${n.name.value}' changed type from '${t}' to '${s}'`)}function R(e,n,o=!1){if(!g(e)&&!g(n))return e.toString()===n.toString();if(b(n)){return R(b(e)?e.type:e,n.type)}return b(e)?R(n,e,o):!!O(e)&&(O(n)&&R(e.type,n.type)||b(n)&&R(e,n.type))}function j(e,n,o){if(n)try{return{name:e.name,description:e.description||n.description,kind:(null==o?void 0:o.convertExtensions)||"InputObjectTypeDefinition"===e.kind||"InputObjectTypeDefinition"===n.kind?"InputObjectTypeDefinition":"InputObjectTypeExtension",loc:e.loc,fields:D(e,e.fields,n.fields,o),directives:_(e.directives,n.directives,o)}}catch(i){throw new Error(`Unable to merge GraphQL input type "${e.name.value}": ${i.message}`)}return(null==o?void 0:o.convertExtensions)?{...e,kind:u.h.INPUT_OBJECT_TYPE_DEFINITION}:e}function C(e,n,o){if(n)try{return{name:e.name,description:e.description||n.description,kind:(null==o?void 0:o.convertExtensions)||"InterfaceTypeDefinition"===e.kind||"InterfaceTypeDefinition"===n.kind?"InterfaceTypeDefinition":"InterfaceTypeExtension",loc:e.loc,fields:D(e,e.fields,n.fields,o),directives:_(e.directives,n.directives,o)}}catch(i){throw new Error(`Unable to merge GraphQL interface "${e.name.value}": ${i.message}`)}return(null==o?void 0:o.convertExtensions)?{...e,kind:u.h.INTERFACE_TYPE_DEFINITION}:e}function P(e=[],n=[],o={}){const i=[...n,...e.filter((e=>{return o=e,!n.find((e=>e.name.value===o.name.value));var o}))];return o&&o.sort&&i.sort(c.YU),i}function Y(e,n,o){if(n)try{return{name:e.name,description:e.description||n.description,kind:(null==o?void 0:o.convertExtensions)||"ObjectTypeDefinition"===e.kind||"ObjectTypeDefinition"===n.kind?"ObjectTypeDefinition":"ObjectTypeExtension",loc:e.loc,fields:D(e,e.fields,n.fields,o),directives:_(e.directives,n.directives,o),interfaces:P(e.interfaces,n.interfaces,o)}}catch(i){throw new Error(`Unable to merge GraphQL type "${e.name.value}": ${i.message}`)}return(null==o?void 0:o.convertExtensions)?{...e,kind:u.h.OBJECT_TYPE_DEFINITION}:e}function $(e,n,o){return n?{name:e.name,description:e.description||n.description,kind:(null==o?void 0:o.convertExtensions)||"ScalarTypeDefinition"===e.kind||"ScalarTypeDefinition"===n.kind?"ScalarTypeDefinition":"ScalarTypeExtension",loc:e.loc,directives:_(e.directives,n.directives,o)}:(null==o?void 0:o.convertExtensions)?{...e,kind:u.h.SCALAR_TYPE_DEFINITION}:e}function M(e,n,o){return n?{name:e.name,description:e.description||n.description,directives:_(e.directives,n.directives,o),kind:(null==o?void 0:o.convertExtensions)||"UnionTypeDefinition"===e.kind||"UnionTypeDefinition"===n.kind?u.h.UNION_TYPE_DEFINITION:u.h.UNION_TYPE_EXTENSION,loc:e.loc,types:P(e.types,n.types,o)}:(null==o?void 0:o.convertExtensions)?{...e,kind:u.h.UNION_TYPE_DEFINITION}:e}!function(e){e[e.A_SMALLER_THAN_B=-1]="A_SMALLER_THAN_B",e[e.A_EQUALS_B=0]="A_EQUALS_B",e[e.A_GREATER_THAN_B=1]="A_GREATER_THAN_B"}(i||(i={}));const U={query:"Query",mutation:"Mutation",subscription:"Subscription"};function L(e=[],n=[]){const o=[];for(const i in U){const t=e.find((e=>e.operation===i))||n.find((e=>e.operation===i));t&&o.push(t)}return o}function B(e,n,o){return n?{kind:e.kind===u.h.SCHEMA_DEFINITION||n.kind===u.h.SCHEMA_DEFINITION?u.h.SCHEMA_DEFINITION:u.h.SCHEMA_EXTENSION,description:e.description||n.description,directives:_(e.directives,n.directives,o),operationTypes:L(e.operationTypes,n.operationTypes)}:(null==o?void 0:o.convertExtensions)?{...e,kind:u.h.SCHEMA_DEFINITION}:e}const H="SCHEMA_DEF_SYMBOL";function q(e,n){(0,c.BX)();const o={kind:u.h.DOCUMENT,definitions:W(e,{useSchemaDefinition:!0,forceSchemaDefinition:!1,throwOnConflict:!1,commentDescriptions:!1,...n})};let i;return i=(null==n?void 0:n.commentDescriptions)?(0,c.d2)(o):o,(0,c.BX)(),i}function V(e,n,o=[],i=new Set){if(e&&!i.has(e))if(i.add(e),"function"==typeof e)V(e(),n,o,i);else if(Array.isArray(e))for(const t of e)V(t,n,o,i);else if((0,s.nN)(e)){V((0,c.HA)(e,n).definitions,n,o,i)}else if("string"==typeof e||function(e){return e instanceof d.H}(e)){V((0,f.Qc)(e,n).definitions,n,o,i)}else if("object"==typeof e&&(0,v.Ir)(e))o.push(e);else{if(!(0,c.JW)(e))throw new Error("typeDefs must contain only strings, documents, schemas, or functions, got "+typeof e);V(e.definitions,n,o,i)}return o}function W(e,n){var o,i,t;(0,c.BX)();const s=function(e,n){var o,i,t;const s={};for(const r of e)if("name"in r){const e=null===(o=r.name)||void 0===o?void 0:o.value;if((null==n?void 0:n.commentDescriptions)&&(0,c.Jx)(r),null==e)continue;if((null===(i=null==n?void 0:n.exclusions)||void 0===i?void 0:i.includes(e+".*"))||(null===(t=null==n?void 0:n.exclusions)||void 0===t?void 0:t.includes(e)))delete s[e];else switch(r.kind){case u.h.OBJECT_TYPE_DEFINITION:case u.h.OBJECT_TYPE_EXTENSION:s[e]=Y(r,s[e],n);break;case u.h.ENUM_TYPE_DEFINITION:case u.h.ENUM_TYPE_EXTENSION:s[e]=x(r,s[e],n);break;case u.h.UNION_TYPE_DEFINITION:case u.h.UNION_TYPE_EXTENSION:s[e]=M(r,s[e],n);break;case u.h.SCALAR_TYPE_DEFINITION:case u.h.SCALAR_TYPE_EXTENSION:s[e]=$(r,s[e],n);break;case u.h.INPUT_OBJECT_TYPE_DEFINITION:case u.h.INPUT_OBJECT_TYPE_EXTENSION:s[e]=j(r,s[e],n);break;case u.h.INTERFACE_TYPE_DEFINITION:case u.h.INTERFACE_TYPE_EXTENSION:s[e]=C(r,s[e],n);break;case u.h.DIRECTIVE_DEFINITION:s[e]=h(r,s[e])}}else r.kind!==u.h.SCHEMA_DEFINITION&&r.kind!==u.h.SCHEMA_EXTENSION||(s[H]=B(r,s[H],n));return s}(V(e,n),n);if(null==n?void 0:n.useSchemaDefinition){const e=s[H]||{kind:u.h.SCHEMA_DEFINITION,operationTypes:[]},n=e.operationTypes;for(const o in U){if(!n.find((e=>e.operation===o))){const e=s[U[o]];null!=e&&null!=e.name&&n.push({kind:u.h.OPERATION_TYPE_DEFINITION,type:{kind:u.h.NAMED_TYPE,name:e.name},operation:o})}}null!=(null===(o=null==e?void 0:e.operationTypes)||void 0===o?void 0:o.length)&&e.operationTypes.length>0&&(s[H]=e)}(null==n?void 0:n.forceSchemaDefinition)&&!(null===(t=null===(i=s[H])||void 0===i?void 0:i.operationTypes)||void 0===t?void 0:t.length)&&(s[H]={kind:u.h.SCHEMA_DEFINITION,operationTypes:[{kind:u.h.OPERATION_TYPE_DEFINITION,operation:"query",type:{kind:u.h.NAMED_TYPE,name:{kind:u.h.NAME,value:"Query"}}}]});const r=Object.values(s);if(null==n?void 0:n.sort){const e="function"==typeof n.sort?n.sort:F;r.sort(((n,o)=>{var i,t;return e(null===(i=n.name)||void 0===i?void 0:i.value,null===(t=o.name)||void 0===t?void 0:t.value)}))}return r}function X(e,n){e&&(e.extensions=(0,c.Ee)([e.extensions||{},n||{}]))}function Q(e){const n={schemaExtensions:{},types:{}};return function(e,n){n.onSchema(e);const o=e.getTypeMap();for(const[,i]of Object.entries(o)){const e=(0,t.KA)(i)&&(0,r.u1)(i),o=(0,p.s9)(i);if(!e&&!o)if((0,t.lp)(i)){n.onObjectType(i);const e=i.getFields();for(const[,o]of Object.entries(e)){n.onObjectField(i,o);const e=o.args||[];for(const t of e)n.onObjectFieldArg(i,o,t)}}else if((0,t.oT)(i)){n.onInterface(i);const e=i.getFields();for(const[,o]of Object.entries(e)){n.onInterfaceField(i,o);const e=o.args||[];for(const t of e)n.onInterfaceFieldArg(i,o,t)}}else if((0,t.hL)(i)){n.onInputType(i);const e=i.getFields();for(const[,o]of Object.entries(e))n.onInputFieldType(i,o)}else if((0,t.EN)(i))n.onUnion(i);else if((0,t.KA)(i))n.onScalar(i);else if((0,t.EM)(i)){n.onEnum(i);for(const e of i.getValues())n.onEnumValue(i,e)}}}(e,{onSchema:e=>n.schemaExtensions=e.extensions||{},onObjectType:e=>n.types[e.name]={fields:{},type:"object",extensions:e.extensions||{}},onObjectField:(e,o)=>n.types[e.name].fields[o.name]={arguments:{},extensions:o.extensions||{}},onObjectFieldArg:(e,o,i)=>n.types[e.name].fields[o.name].arguments[i.name]=i.extensions||{},onInterface:e=>n.types[e.name]={fields:{},type:"interface",extensions:e.extensions||{}},onInterfaceField:(e,o)=>n.types[e.name].fields[o.name]={arguments:{},extensions:o.extensions||{}},onInterfaceFieldArg:(e,o,i)=>n.types[e.name].fields[o.name].arguments[i.name]=i.extensions||{},onEnum:e=>n.types[e.name]={values:{},type:"enum",extensions:e.extensions||{}},onEnumValue:(e,o)=>n.types[e.name].values[o.name]=o.extensions||{},onScalar:e=>n.types[e.name]={type:"scalar",extensions:e.extensions||{}},onUnion:e=>n.types[e.name]={type:"union",extensions:e.extensions||{}},onInputType:e=>n.types[e.name]={fields:{},type:"input",extensions:e.extensions||{}},onInputFieldType:(e,o)=>n.types[e.name].fields[o.name]={extensions:o.extensions||{}}}),n}var J=o(30138);function G(e,n,o,i,t){if(o.resolve){if("function"!=typeof o.resolve)throw new Error(`Resolver "${i}.${t}" must be a function`)}else{const o=`Resolver missing for "${i}.${t}".\nTo disable this validator, use:\n  resolverValidationOptions: {\n    ${e}: 'ignore'\n  }`;if("error"===n)throw new Error(o);"warn"===n&&J.warn(o)}}function K(e,n,o){const i=(0,s.nN)(e)?{schema:e,resolvers:null!=n?n:{},resolverValidationOptions:o}:e;let{schema:l,resolvers:a,defaultFieldResolver:u,resolverValidationOptions:d={},inheritResolversFromInterfaces:f=!1,updateResolversInPlace:v=!1}=i;const{requireResolversToMatchSchema:p="error",requireResolversForResolveType:E}=d,T=f?function(e,n){const o={},i=e.getTypeMap();for(const t in i){const e=i[t];if("getInterfaces"in e){o[t]={};for(const s of e.getInterfaces())if(n[s.name])for(const e in n[s.name])"__isTypeOf"!==e&&e.startsWith("__")||(o[t][e]=n[s.name][e]);const i=n[t];o[t]={...o[t],...i}}else{const e=n[t];null!=e&&(o[t]=e)}}return o}(l,a):a;for(const s in T){const e=T[s];if("object"!==typeof e)throw new Error(`"${s}" defined in resolvers, but has invalid value "${e}". The resolver's value must be of type object.`);const n=l.getType(s);if(null==n){if("ignore"===p)break;throw new Error(`"${s}" defined in resolvers, but not in schema`)}if((0,r.u1)(n))for(const o in e)o.startsWith("__")?n[o.substring(2)]=e[o]:n[o]=e[o];else if((0,t.EM)(n)){const o=n.getValues();for(const i in e)if(!i.startsWith("__")&&!o.some((e=>e.name===i))&&p&&"ignore"!==p)throw new Error(`${n.name}.${i} was defined in resolvers, but not present within ${n.name}`)}else if((0,t.EN)(n)){for(const o in e)if(!o.startsWith("__")&&p&&"ignore"!==p)throw new Error(`${n.name}.${o} was defined in resolvers, but ${n.name} is not an object or interface type`)}else if((0,t.lp)(n)||(0,t.oT)(n))for(const o in e)if(!o.startsWith("__")){if(null==n.getFields()[o]){if(p&&"ignore"!==p)throw new Error(`${s}.${o} defined in resolvers, but not in schema`)}else{const n=e[o];if("function"!=typeof n&&"object"!=typeof n)throw new Error(`Resolver ${s}.${o} must be object or function`)}}}return l=v?function(e,n,o){var i,s,r,l,a,u,d,f,v,p,E,T,m,N,_,h,y,I;const x=e.getTypeMap();for(const c in n){const o=e.getType(c),A=n[c];if((0,t.KA)(o))for(const e in A)e.startsWith("__")?o[e.substring(2)]=A[e]:"astNode"===e&&null!=o.astNode?o.astNode={...o.astNode,description:null!==(r=null===(s=null===(i=A)||void 0===i?void 0:i.astNode)||void 0===s?void 0:s.description)&&void 0!==r?r:o.astNode.description,directives:(null!==(l=o.astNode.directives)&&void 0!==l?l:[]).concat(null!==(d=null===(u=null===(a=A)||void 0===a?void 0:a.astNode)||void 0===u?void 0:u.directives)&&void 0!==d?d:[])}:"extensionASTNodes"===e&&null!=o.extensionASTNodes?o.extensionASTNodes=o.extensionASTNodes.concat(null!==(v=null===(f=A)||void 0===f?void 0:f.extensionASTNodes)&&void 0!==v?v:[]):"extensions"===e&&null!=o.extensions&&null!=A.extensions?o.extensions=Object.assign(Object.create(null),o.extensions,A.extensions):o[e]=A[e];else if((0,t.EM)(o)){const e=o.toConfig(),n=e.values;for(const i in A)i.startsWith("__")?e[i.substring(2)]=A[i]:"astNode"===i&&null!=e.astNode?e.astNode={...e.astNode,description:null!==(T=null===(E=null===(p=A)||void 0===p?void 0:p.astNode)||void 0===E?void 0:E.description)&&void 0!==T?T:e.astNode.description,directives:(null!==(m=e.astNode.directives)&&void 0!==m?m:[]).concat(null!==(h=null===(_=null===(N=A)||void 0===N?void 0:N.astNode)||void 0===_?void 0:_.directives)&&void 0!==h?h:[])}:"extensionASTNodes"===i&&null!=e.extensionASTNodes?e.extensionASTNodes=e.extensionASTNodes.concat(null!==(I=null===(y=A)||void 0===y?void 0:y.extensionASTNodes)&&void 0!==I?I:[]):"extensions"===i&&null!=o.extensions&&null!=A.extensions?o.extensions=Object.assign(Object.create(null),o.extensions,A.extensions):n[i]&&(n[i].value=A[i]);x[c]=new t.mR(e)}else if((0,t.EN)(o))for(const e in A)e.startsWith("__")&&(o[e.substring(2)]=A[e]);else if((0,t.lp)(o)||(0,t.oT)(o))for(const e in A){if(e.startsWith("__")){o[e.substring(2)]=A[e];break}const n=o.getFields()[e];if(null!=n){const o=A[e];"function"==typeof o?n.resolve=o.bind(A):z(n,o)}}}(0,c.pD)(e,c.RF),(0,c.r8)(e),(0,c.pD)(e,c.Oe),null!=o&&(0,c.pY)(e,(e=>{e.resolve||(e.resolve=o)}));return e}(l,T,u):function(e,n,o){e=(0,c.gf)(e,{[c.h0.SCALAR_TYPE]:e=>{var o,i,s,l,c,a,u,d,f;const v=e.toConfig(),p=n[e.name];if(!(0,r.u1)(e)&&null!=p){for(const n in p)n.startsWith("__")?v[n.substring(2)]=p[n]:"astNode"===n&&null!=v.astNode?v.astNode={...v.astNode,description:null!==(s=null===(i=null===(o=p)||void 0===o?void 0:o.astNode)||void 0===i?void 0:i.description)&&void 0!==s?s:v.astNode.description,directives:(null!==(l=v.astNode.directives)&&void 0!==l?l:[]).concat(null!==(u=null===(a=null===(c=p)||void 0===c?void 0:c.astNode)||void 0===a?void 0:a.directives)&&void 0!==u?u:[])}:"extensionASTNodes"===n&&null!=v.extensionASTNodes?v.extensionASTNodes=v.extensionASTNodes.concat(null!==(f=null===(d=p)||void 0===d?void 0:d.extensionASTNodes)&&void 0!==f?f:[]):"extensions"===n&&null!=v.extensions&&null!=p.extensions?v.extensions=Object.assign(Object.create(null),e.extensions,p.extensions):v[n]=p[n];return new t.n2(v)}},[c.h0.ENUM_TYPE]:e=>{var o,i,s,r,l,c,a,u,d;const f=n[e.name],v=e.toConfig(),p=v.values;if(null!=f){for(const n in f)n.startsWith("__")?v[n.substring(2)]=f[n]:"astNode"===n&&null!=v.astNode?v.astNode={...v.astNode,description:null!==(s=null===(i=null===(o=f)||void 0===o?void 0:o.astNode)||void 0===i?void 0:i.description)&&void 0!==s?s:v.astNode.description,directives:(null!==(r=v.astNode.directives)&&void 0!==r?r:[]).concat(null!==(a=null===(c=null===(l=f)||void 0===l?void 0:l.astNode)||void 0===c?void 0:c.directives)&&void 0!==a?a:[])}:"extensionASTNodes"===n&&null!=v.extensionASTNodes?v.extensionASTNodes=v.extensionASTNodes.concat(null!==(d=null===(u=f)||void 0===u?void 0:u.extensionASTNodes)&&void 0!==d?d:[]):"extensions"===n&&null!=v.extensions&&null!=f.extensions?v.extensions=Object.assign(Object.create(null),e.extensions,f.extensions):p[n]&&(p[n].value=f[n]);return new t.mR(v)}},[c.h0.UNION_TYPE]:e=>{const o=n[e.name];if(null!=o){const n=e.toConfig();return o.__resolveType&&(n.resolveType=o.__resolveType),new t.Gp(n)}},[c.h0.OBJECT_TYPE]:e=>{const o=n[e.name];if(null!=o){const n=e.toConfig();return o.__isTypeOf&&(n.isTypeOf=o.__isTypeOf),new t.h6(n)}},[c.h0.INTERFACE_TYPE]:e=>{const o=n[e.name];if(null!=o){const n=e.toConfig();return o.__resolveType&&(n.resolveType=o.__resolveType),new t.oW(n)}},[c.h0.COMPOSITE_FIELD]:(e,o,i)=>{const t=n[i];if(null!=t){const n=t[o];if(null!=n){const o={...e};return"function"==typeof n?o.resolve=n.bind(t):z(o,n),o}}}}),null!=o&&(e=(0,c.gf)(e,{[c.h0.OBJECT_FIELD]:e=>({...e,resolve:null!=e.resolve?e.resolve:o})}));return e}(l,T,u),E&&"ignore"!==E&&function(e,n){(0,c.gf)(e,{[c.h0.ABSTRACT_TYPE]:e=>{if(!e.resolveType){const o=`Type "${e.name}" is missing a "__resolveType" resolver. Pass 'ignore' into "resolverValidationOptions.requireResolversForResolveType" to disable this error.`;if("error"===n)throw new Error(o);"warn"===n&&J.warn(o)}}})}(l,E),l}function z(e,n){for(const o in n)e[o]=n[o]}function Z({typeDefs:e,resolvers:n={},resolverValidationOptions:o={},parseOptions:i={},inheritResolversFromInterfaces:r=!1,pruningOptions:a,updateResolversInPlace:u=!1,schemaExtensions:d}){if("object"!=typeof o)throw new Error("Expected `resolverValidationOptions` to be an object");if(!e)throw new Error("Must provide typeDefs");let f;if((0,s.nN)(e))f=e;else if(null==i?void 0:i.commentDescriptions){const n=q(e,{...i,commentDescriptions:!0});f=(0,l.I)(n,i)}else{const n=q(e,i);f=(0,l.M)(n,i)}var v;return a&&(f=(0,c.h1)(f)),f=K({schema:f,resolvers:E(n),resolverValidationOptions:o,inheritResolversFromInterfaces:r,updateResolversInPlace:u}),Object.keys(o).length>0&&function(e,n={}){const{requireResolversForArgs:o,requireResolversForNonScalar:i,requireResolversForAllFields:s}=n;if(s&&(o||i))throw new TypeError("requireResolversForAllFields takes precedence over the more specific assertions. Please configure either requireResolversForAllFields or requireResolversForArgs / requireResolversForNonScalar, but not a combination of them.");(0,c.pY)(e,((e,n,r)=>{s&&G("requireResolversForAllFields",s,e,n,r),o&&e.args.length>0&&G("requireResolversForArgs",o,e,n,r),"ignore"===i||(0,t.KA)((0,t.xC)(e.type))||G("requireResolversForNonScalar",i,e,n,r)}))}(f,o),d&&(v=(0,c._2)(d),function(e,n){X(e,n.schemaExtensions);for(const[o,i]of Object.entries(n.types||{})){const n=e.getType(o);if(n)if(X(n,i.extensions),"object"===i.type||"interface"===i.type)for(const[e,o]of Object.entries(i.fields)){const i=n.getFields()[e];if(i){X(i,o.extensions);for(const[e,n]of Object.entries(o.arguments))X(i.args.find((n=>n.name===e)),n)}}else if("input"===i.type)for(const[e,o]of Object.entries(i.fields))X(n.getFields()[e],o.extensions);else if("enum"===i.type)for(const[e,o]of Object.entries(i.values))X(n.getValue(e),o)}}(f,d=(0,c.Ee)(v))),f}function ee(e){const n=(0,c._2)(e.typeDefs||[]),o=(0,c._2)(e.resolvers||[]),i=(0,c._2)(e.schemaExtensions||[]),t=e.schemas||[];for(const s of t)n.push(s),o.push((0,c.wq)(s)),i.push(Q(s));return Z({parseOptions:e,...e,typeDefs:n,resolvers:o,schemaExtensions:i})}}}]);